import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { GlueServiceException as __BaseException } from "./GlueServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export interface NotificationProperty {
  NotifyDelayAfter?: number;
}
export interface Action {
  JobName?: string;
  Arguments?: Record<string, string>;
  Timeout?: number;
  SecurityConfiguration?: string;
  NotificationProperty?: NotificationProperty;
  CrawlerName?: string;
}
export declare const AdditionalOptionKeys: {
  readonly CacheOption: "performanceTuning.caching";
  readonly ObservationsOption: "observations.scope";
};
export type AdditionalOptionKeys =
  (typeof AdditionalOptionKeys)[keyof typeof AdditionalOptionKeys];
export declare const AggFunction: {
  readonly avg: "avg";
  readonly count: "count";
  readonly countDistinct: "countDistinct";
  readonly first: "first";
  readonly kurtosis: "kurtosis";
  readonly last: "last";
  readonly max: "max";
  readonly min: "min";
  readonly skewness: "skewness";
  readonly stddev_pop: "stddev_pop";
  readonly stddev_samp: "stddev_samp";
  readonly sum: "sum";
  readonly sumDistinct: "sumDistinct";
  readonly var_pop: "var_pop";
  readonly var_samp: "var_samp";
};
export type AggFunction = (typeof AggFunction)[keyof typeof AggFunction];
export interface AggregateOperation {
  Column: string[] | undefined;
  AggFunc: AggFunction | undefined;
}
export interface Aggregate {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Groups: string[][] | undefined;
  Aggs: AggregateOperation[] | undefined;
}
export declare class AlreadyExistsException extends __BaseException {
  readonly name: "AlreadyExistsException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<AlreadyExistsException, __BaseException>
  );
}
export interface AmazonRedshiftAdvancedOption {
  Key?: string;
  Value?: string;
}
export interface Option {
  Value?: string;
  Label?: string;
  Description?: string;
}
export interface AmazonRedshiftNodeData {
  AccessType?: string;
  SourceType?: string;
  Connection?: Option;
  Schema?: Option;
  Table?: Option;
  CatalogDatabase?: Option;
  CatalogTable?: Option;
  CatalogRedshiftSchema?: string;
  CatalogRedshiftTable?: string;
  TempDir?: string;
  IamRole?: Option;
  AdvancedOptions?: AmazonRedshiftAdvancedOption[];
  SampleQuery?: string;
  PreAction?: string;
  PostAction?: string;
  Action?: string;
  TablePrefix?: string;
  Upsert?: boolean;
  MergeAction?: string;
  MergeWhenMatched?: string;
  MergeWhenNotMatched?: string;
  MergeClause?: string;
  CrawlerConnection?: string;
  TableSchema?: Option[];
  StagingTable?: string;
  SelectedColumns?: Option[];
}
export interface AmazonRedshiftSource {
  Name?: string;
  Data?: AmazonRedshiftNodeData;
}
export interface AmazonRedshiftTarget {
  Name?: string;
  Data?: AmazonRedshiftNodeData;
  Inputs?: string[];
}
export interface GlueStudioSchemaColumn {
  Name: string | undefined;
  Type?: string;
}
export interface GlueSchema {
  Columns?: GlueStudioSchemaColumn[];
}
export interface AthenaConnectorSource {
  Name: string | undefined;
  ConnectionName: string | undefined;
  ConnectorName: string | undefined;
  ConnectionType: string | undefined;
  ConnectionTable?: string;
  SchemaName: string | undefined;
  OutputSchemas?: GlueSchema[];
}
export interface AuditContext {
  AdditionalAuditContext?: string;
  RequestedColumns?: string[];
  AllColumnsRequested?: boolean;
}
export interface Column {
  Name: string | undefined;
  Type?: string;
  Comment?: string;
  Parameters?: Record<string, string>;
}
export interface SchemaId {
  SchemaArn?: string;
  SchemaName?: string;
  RegistryName?: string;
}
export interface SchemaReference {
  SchemaId?: SchemaId;
  SchemaVersionId?: string;
  SchemaVersionNumber?: number;
}
export interface SerDeInfo {
  Name?: string;
  SerializationLibrary?: string;
  Parameters?: Record<string, string>;
}
export interface SkewedInfo {
  SkewedColumnNames?: string[];
  SkewedColumnValues?: string[];
  SkewedColumnValueLocationMaps?: Record<string, string>;
}
export interface Order {
  Column: string | undefined;
  SortOrder: number | undefined;
}
export interface StorageDescriptor {
  Columns?: Column[];
  Location?: string;
  AdditionalLocations?: string[];
  InputFormat?: string;
  OutputFormat?: string;
  Compressed?: boolean;
  NumberOfBuckets?: number;
  SerdeInfo?: SerDeInfo;
  BucketColumns?: string[];
  SortColumns?: Order[];
  Parameters?: Record<string, string>;
  SkewedInfo?: SkewedInfo;
  StoredAsSubDirectories?: boolean;
  SchemaReference?: SchemaReference;
}
export interface PartitionInput {
  Values?: string[];
  LastAccessTime?: Date;
  StorageDescriptor?: StorageDescriptor;
  Parameters?: Record<string, string>;
  LastAnalyzedTime?: Date;
}
export interface BatchCreatePartitionRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  PartitionInputList: PartitionInput[] | undefined;
}
export interface ErrorDetail {
  ErrorCode?: string;
  ErrorMessage?: string;
}
export interface PartitionError {
  PartitionValues?: string[];
  ErrorDetail?: ErrorDetail;
}
export interface BatchCreatePartitionResponse {
  Errors?: PartitionError[];
}
export declare class EntityNotFoundException extends __BaseException {
  readonly name: "EntityNotFoundException";
  readonly $fault: "client";
  Message?: string;
  FromFederationSource?: boolean;
  constructor(
    opts: __ExceptionOptionType<EntityNotFoundException, __BaseException>
  );
}
export declare class GlueEncryptionException extends __BaseException {
  readonly name: "GlueEncryptionException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<GlueEncryptionException, __BaseException>
  );
}
export declare class InternalServiceException extends __BaseException {
  readonly name: "InternalServiceException";
  readonly $fault: "server";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InternalServiceException, __BaseException>
  );
}
export declare class InvalidInputException extends __BaseException {
  readonly name: "InvalidInputException";
  readonly $fault: "client";
  Message?: string;
  FromFederationSource?: boolean;
  constructor(
    opts: __ExceptionOptionType<InvalidInputException, __BaseException>
  );
}
export declare class OperationTimeoutException extends __BaseException {
  readonly name: "OperationTimeoutException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<OperationTimeoutException, __BaseException>
  );
}
export declare class ResourceNumberLimitExceededException extends __BaseException {
  readonly name: "ResourceNumberLimitExceededException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      ResourceNumberLimitExceededException,
      __BaseException
    >
  );
}
export interface BatchDeleteConnectionRequest {
  CatalogId?: string;
  ConnectionNameList: string[] | undefined;
}
export interface BatchDeleteConnectionResponse {
  Succeeded?: string[];
  Errors?: Record<string, ErrorDetail>;
}
export interface PartitionValueList {
  Values: string[] | undefined;
}
export interface BatchDeletePartitionRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  PartitionsToDelete: PartitionValueList[] | undefined;
}
export interface BatchDeletePartitionResponse {
  Errors?: PartitionError[];
}
export interface BatchDeleteTableRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TablesToDelete: string[] | undefined;
  TransactionId?: string;
}
export interface TableError {
  TableName?: string;
  ErrorDetail?: ErrorDetail;
}
export interface BatchDeleteTableResponse {
  Errors?: TableError[];
}
export declare class ResourceNotReadyException extends __BaseException {
  readonly name: "ResourceNotReadyException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceNotReadyException, __BaseException>
  );
}
export interface BatchDeleteTableVersionRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  VersionIds: string[] | undefined;
}
export interface TableVersionError {
  TableName?: string;
  VersionId?: string;
  ErrorDetail?: ErrorDetail;
}
export interface BatchDeleteTableVersionResponse {
  Errors?: TableVersionError[];
}
export interface BatchGetBlueprintsRequest {
  Names: string[] | undefined;
  IncludeBlueprint?: boolean;
  IncludeParameterSpec?: boolean;
}
export interface LastActiveDefinition {
  Description?: string;
  LastModifiedOn?: Date;
  ParameterSpec?: string;
  BlueprintLocation?: string;
  BlueprintServiceLocation?: string;
}
export declare const BlueprintStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly CREATING: "CREATING";
  readonly FAILED: "FAILED";
  readonly UPDATING: "UPDATING";
};
export type BlueprintStatus =
  (typeof BlueprintStatus)[keyof typeof BlueprintStatus];
export interface Blueprint {
  Name?: string;
  Description?: string;
  CreatedOn?: Date;
  LastModifiedOn?: Date;
  ParameterSpec?: string;
  BlueprintLocation?: string;
  BlueprintServiceLocation?: string;
  Status?: BlueprintStatus;
  ErrorMessage?: string;
  LastActiveDefinition?: LastActiveDefinition;
}
export interface BatchGetBlueprintsResponse {
  Blueprints?: Blueprint[];
  MissingBlueprints?: string[];
}
export interface BatchGetCrawlersRequest {
  CrawlerNames: string[] | undefined;
}
export interface LakeFormationConfiguration {
  UseLakeFormationCredentials?: boolean;
  AccountId?: string;
}
export declare const LastCrawlStatus: {
  readonly CANCELLED: "CANCELLED";
  readonly FAILED: "FAILED";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type LastCrawlStatus =
  (typeof LastCrawlStatus)[keyof typeof LastCrawlStatus];
export interface LastCrawlInfo {
  Status?: LastCrawlStatus;
  ErrorMessage?: string;
  LogGroup?: string;
  LogStream?: string;
  MessagePrefix?: string;
  StartTime?: Date;
}
export declare const CrawlerLineageSettings: {
  readonly DISABLE: "DISABLE";
  readonly ENABLE: "ENABLE";
};
export type CrawlerLineageSettings =
  (typeof CrawlerLineageSettings)[keyof typeof CrawlerLineageSettings];
export interface LineageConfiguration {
  CrawlerLineageSettings?: CrawlerLineageSettings;
}
export declare const RecrawlBehavior: {
  readonly CRAWL_EVENT_MODE: "CRAWL_EVENT_MODE";
  readonly CRAWL_EVERYTHING: "CRAWL_EVERYTHING";
  readonly CRAWL_NEW_FOLDERS_ONLY: "CRAWL_NEW_FOLDERS_ONLY";
};
export type RecrawlBehavior =
  (typeof RecrawlBehavior)[keyof typeof RecrawlBehavior];
export interface RecrawlPolicy {
  RecrawlBehavior?: RecrawlBehavior;
}
export declare const ScheduleState: {
  readonly NOT_SCHEDULED: "NOT_SCHEDULED";
  readonly SCHEDULED: "SCHEDULED";
  readonly TRANSITIONING: "TRANSITIONING";
};
export type ScheduleState = (typeof ScheduleState)[keyof typeof ScheduleState];
export interface Schedule {
  ScheduleExpression?: string;
  State?: ScheduleState;
}
export declare const DeleteBehavior: {
  readonly DELETE_FROM_DATABASE: "DELETE_FROM_DATABASE";
  readonly DEPRECATE_IN_DATABASE: "DEPRECATE_IN_DATABASE";
  readonly LOG: "LOG";
};
export type DeleteBehavior =
  (typeof DeleteBehavior)[keyof typeof DeleteBehavior];
export declare const UpdateBehavior: {
  readonly LOG: "LOG";
  readonly UPDATE_IN_DATABASE: "UPDATE_IN_DATABASE";
};
export type UpdateBehavior =
  (typeof UpdateBehavior)[keyof typeof UpdateBehavior];
export interface SchemaChangePolicy {
  UpdateBehavior?: UpdateBehavior;
  DeleteBehavior?: DeleteBehavior;
}
export declare const CrawlerState: {
  readonly READY: "READY";
  readonly RUNNING: "RUNNING";
  readonly STOPPING: "STOPPING";
};
export type CrawlerState = (typeof CrawlerState)[keyof typeof CrawlerState];
export interface CatalogTarget {
  DatabaseName: string | undefined;
  Tables: string[] | undefined;
  ConnectionName?: string;
  EventQueueArn?: string;
  DlqEventQueueArn?: string;
}
export interface DeltaTarget {
  DeltaTables?: string[];
  ConnectionName?: string;
  WriteManifest?: boolean;
  CreateNativeDeltaTable?: boolean;
}
export interface DynamoDBTarget {
  Path?: string;
  scanAll?: boolean;
  scanRate?: number;
}
export interface HudiTarget {
  Paths?: string[];
  ConnectionName?: string;
  Exclusions?: string[];
  MaximumTraversalDepth?: number;
}
export interface IcebergTarget {
  Paths?: string[];
  ConnectionName?: string;
  Exclusions?: string[];
  MaximumTraversalDepth?: number;
}
export declare const JdbcMetadataEntry: {
  readonly COMMENTS: "COMMENTS";
  readonly RAWTYPES: "RAWTYPES";
};
export type JdbcMetadataEntry =
  (typeof JdbcMetadataEntry)[keyof typeof JdbcMetadataEntry];
export interface JdbcTarget {
  ConnectionName?: string;
  Path?: string;
  Exclusions?: string[];
  EnableAdditionalMetadata?: JdbcMetadataEntry[];
}
export interface MongoDBTarget {
  ConnectionName?: string;
  Path?: string;
  ScanAll?: boolean;
}
export interface S3Target {
  Path?: string;
  Exclusions?: string[];
  ConnectionName?: string;
  SampleSize?: number;
  EventQueueArn?: string;
  DlqEventQueueArn?: string;
}
export interface CrawlerTargets {
  S3Targets?: S3Target[];
  JdbcTargets?: JdbcTarget[];
  MongoDBTargets?: MongoDBTarget[];
  DynamoDBTargets?: DynamoDBTarget[];
  CatalogTargets?: CatalogTarget[];
  DeltaTargets?: DeltaTarget[];
  IcebergTargets?: IcebergTarget[];
  HudiTargets?: HudiTarget[];
}
export interface Crawler {
  Name?: string;
  Role?: string;
  Targets?: CrawlerTargets;
  DatabaseName?: string;
  Description?: string;
  Classifiers?: string[];
  RecrawlPolicy?: RecrawlPolicy;
  SchemaChangePolicy?: SchemaChangePolicy;
  LineageConfiguration?: LineageConfiguration;
  State?: CrawlerState;
  TablePrefix?: string;
  Schedule?: Schedule;
  CrawlElapsedTime?: number;
  CreationTime?: Date;
  LastUpdated?: Date;
  LastCrawl?: LastCrawlInfo;
  Version?: number;
  Configuration?: string;
  CrawlerSecurityConfiguration?: string;
  LakeFormationConfiguration?: LakeFormationConfiguration;
}
export interface BatchGetCrawlersResponse {
  Crawlers?: Crawler[];
  CrawlersNotFound?: string[];
}
export interface BatchGetCustomEntityTypesRequest {
  Names: string[] | undefined;
}
export interface CustomEntityType {
  Name: string | undefined;
  RegexString: string | undefined;
  ContextWords?: string[];
}
export interface BatchGetCustomEntityTypesResponse {
  CustomEntityTypes?: CustomEntityType[];
  CustomEntityTypesNotFound?: string[];
}
export interface BatchGetDataQualityResultRequest {
  ResultIds: string[] | undefined;
}
export interface DataQualityAnalyzerResult {
  Name?: string;
  Description?: string;
  EvaluationMessage?: string;
  EvaluatedMetrics?: Record<string, number>;
}
export interface GlueTable {
  DatabaseName: string | undefined;
  TableName: string | undefined;
  CatalogId?: string;
  ConnectionName?: string;
  AdditionalOptions?: Record<string, string>;
}
export interface DataSource {
  GlueTable: GlueTable | undefined;
}
export interface DataQualityMetricValues {
  ActualValue?: number;
  ExpectedValue?: number;
  LowerLimit?: number;
  UpperLimit?: number;
}
export interface MetricBasedObservation {
  MetricName?: string;
  MetricValues?: DataQualityMetricValues;
  NewRules?: string[];
}
export interface DataQualityObservation {
  Description?: string;
  MetricBasedObservation?: MetricBasedObservation;
}
export declare const DataQualityRuleResultStatus: {
  readonly ERROR: "ERROR";
  readonly FAIL: "FAIL";
  readonly PASS: "PASS";
};
export type DataQualityRuleResultStatus =
  (typeof DataQualityRuleResultStatus)[keyof typeof DataQualityRuleResultStatus];
export interface DataQualityRuleResult {
  Name?: string;
  Description?: string;
  EvaluationMessage?: string;
  Result?: DataQualityRuleResultStatus;
  EvaluatedMetrics?: Record<string, number>;
}
export interface DataQualityResult {
  ResultId?: string;
  Score?: number;
  DataSource?: DataSource;
  RulesetName?: string;
  EvaluationContext?: string;
  StartedOn?: Date;
  CompletedOn?: Date;
  JobName?: string;
  JobRunId?: string;
  RulesetEvaluationRunId?: string;
  RuleResults?: DataQualityRuleResult[];
  AnalyzerResults?: DataQualityAnalyzerResult[];
  Observations?: DataQualityObservation[];
}
export interface BatchGetDataQualityResultResponse {
  Results: DataQualityResult[] | undefined;
  ResultsNotFound?: string[];
}
export interface BatchGetDevEndpointsRequest {
  DevEndpointNames: string[] | undefined;
}
export declare const WorkerType: {
  readonly G_025X: "G.025X";
  readonly G_1X: "G.1X";
  readonly G_2X: "G.2X";
  readonly G_4X: "G.4X";
  readonly G_8X: "G.8X";
  readonly Standard: "Standard";
  readonly Z_2X: "Z.2X";
};
export type WorkerType = (typeof WorkerType)[keyof typeof WorkerType];
export interface DevEndpoint {
  EndpointName?: string;
  RoleArn?: string;
  SecurityGroupIds?: string[];
  SubnetId?: string;
  YarnEndpointAddress?: string;
  PrivateAddress?: string;
  ZeppelinRemoteSparkInterpreterPort?: number;
  PublicAddress?: string;
  Status?: string;
  WorkerType?: WorkerType;
  GlueVersion?: string;
  NumberOfWorkers?: number;
  NumberOfNodes?: number;
  AvailabilityZone?: string;
  VpcId?: string;
  ExtraPythonLibsS3Path?: string;
  ExtraJarsS3Path?: string;
  FailureReason?: string;
  LastUpdateStatus?: string;
  CreatedTimestamp?: Date;
  LastModifiedTimestamp?: Date;
  PublicKey?: string;
  PublicKeys?: string[];
  SecurityConfiguration?: string;
  Arguments?: Record<string, string>;
}
export interface BatchGetDevEndpointsResponse {
  DevEndpoints?: DevEndpoint[];
  DevEndpointsNotFound?: string[];
}
export interface BatchGetJobsRequest {
  JobNames: string[] | undefined;
}
export interface CatalogDeltaSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
  AdditionalDeltaOptions?: Record<string, string>;
  OutputSchemas?: GlueSchema[];
}
export interface CatalogHudiSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
  AdditionalHudiOptions?: Record<string, string>;
  OutputSchemas?: GlueSchema[];
}
export interface StreamingDataPreviewOptions {
  PollingTime?: number;
  RecordPollingLimit?: number;
}
export interface KafkaStreamingSourceOptions {
  BootstrapServers?: string;
  SecurityProtocol?: string;
  ConnectionName?: string;
  TopicName?: string;
  Assign?: string;
  SubscribePattern?: string;
  Classification?: string;
  Delimiter?: string;
  StartingOffsets?: string;
  EndingOffsets?: string;
  PollTimeoutMs?: number;
  NumRetries?: number;
  RetryIntervalMs?: number;
  MaxOffsetsPerTrigger?: number;
  MinPartitions?: number;
  IncludeHeaders?: boolean;
  AddRecordTimestamp?: string;
  EmitConsumerLagMetrics?: string;
  StartingTimestamp?: Date;
}
export interface CatalogKafkaSource {
  Name: string | undefined;
  WindowSize?: number;
  DetectSchema?: boolean;
  Table: string | undefined;
  Database: string | undefined;
  StreamingOptions?: KafkaStreamingSourceOptions;
  DataPreviewOptions?: StreamingDataPreviewOptions;
}
export declare const StartingPosition: {
  readonly EARLIEST: "earliest";
  readonly LATEST: "latest";
  readonly TIMESTAMP: "timestamp";
  readonly TRIM_HORIZON: "trim_horizon";
};
export type StartingPosition =
  (typeof StartingPosition)[keyof typeof StartingPosition];
export interface KinesisStreamingSourceOptions {
  EndpointUrl?: string;
  StreamName?: string;
  Classification?: string;
  Delimiter?: string;
  StartingPosition?: StartingPosition;
  MaxFetchTimeInMs?: number;
  MaxFetchRecordsPerShard?: number;
  MaxRecordPerRead?: number;
  AddIdleTimeBetweenReads?: boolean;
  IdleTimeBetweenReadsInMs?: number;
  DescribeShardInterval?: number;
  NumRetries?: number;
  RetryIntervalMs?: number;
  MaxRetryIntervalMs?: number;
  AvoidEmptyBatches?: boolean;
  StreamArn?: string;
  RoleArn?: string;
  RoleSessionName?: string;
  AddRecordTimestamp?: string;
  EmitConsumerLagMetrics?: string;
  StartingTimestamp?: Date;
}
export interface CatalogKinesisSource {
  Name: string | undefined;
  WindowSize?: number;
  DetectSchema?: boolean;
  Table: string | undefined;
  Database: string | undefined;
  StreamingOptions?: KinesisStreamingSourceOptions;
  DataPreviewOptions?: StreamingDataPreviewOptions;
}
export interface CatalogSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface BasicCatalogTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface ConnectorDataSource {
  Name: string | undefined;
  ConnectionType: string | undefined;
  Data: Record<string, string> | undefined;
  OutputSchemas?: GlueSchema[];
}
export interface ConnectorDataTarget {
  Name: string | undefined;
  ConnectionType: string | undefined;
  Data: Record<string, string> | undefined;
  Inputs?: string[];
}
export interface CustomCode {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Code: string | undefined;
  ClassName: string | undefined;
  OutputSchemas?: GlueSchema[];
}
export declare const JDBCConnectionType: {
  readonly mysql: "mysql";
  readonly oracle: "oracle";
  readonly postgresql: "postgresql";
  readonly redshift: "redshift";
  readonly sqlserver: "sqlserver";
};
export type JDBCConnectionType =
  (typeof JDBCConnectionType)[keyof typeof JDBCConnectionType];
export interface DirectJDBCSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
  ConnectionName: string | undefined;
  ConnectionType: JDBCConnectionType | undefined;
  RedshiftTmpDir?: string;
}
export interface DirectKafkaSource {
  Name: string | undefined;
  StreamingOptions?: KafkaStreamingSourceOptions;
  WindowSize?: number;
  DetectSchema?: boolean;
  DataPreviewOptions?: StreamingDataPreviewOptions;
}
export interface DirectKinesisSource {
  Name: string | undefined;
  WindowSize?: number;
  DetectSchema?: boolean;
  StreamingOptions?: KinesisStreamingSourceOptions;
  DataPreviewOptions?: StreamingDataPreviewOptions;
}
export interface DropDuplicates {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Columns?: string[][];
}
export interface DropFields {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Paths: string[][] | undefined;
}
export interface NullCheckBoxList {
  IsEmpty?: boolean;
  IsNullString?: boolean;
  IsNegOne?: boolean;
}
export interface Datatype {
  Id: string | undefined;
  Label: string | undefined;
}
export interface NullValueField {
  Value: string | undefined;
  Datatype: Datatype | undefined;
}
export interface DropNullFields {
  Name: string | undefined;
  Inputs: string[] | undefined;
  NullCheckBoxList?: NullCheckBoxList;
  NullTextList?: NullValueField[];
}
export declare const ParamType: {
  readonly BOOL: "bool";
  readonly COMPLEX: "complex";
  readonly FLOAT: "float";
  readonly INT: "int";
  readonly LIST: "list";
  readonly NULL: "null";
  readonly STR: "str";
};
export type ParamType = (typeof ParamType)[keyof typeof ParamType];
export interface TransformConfigParameter {
  Name: string | undefined;
  Type: ParamType | undefined;
  ValidationRule?: string;
  ValidationMessage?: string;
  Value?: string[];
  ListType?: ParamType;
  IsOptional?: boolean;
}
export interface DynamicTransform {
  Name: string | undefined;
  TransformName: string | undefined;
  Inputs: string[] | undefined;
  Parameters?: TransformConfigParameter[];
  FunctionName: string | undefined;
  Path: string | undefined;
  Version?: string;
  OutputSchemas?: GlueSchema[];
}
export interface DynamoDBCatalogSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export declare const DQTransformOutput: {
  readonly EvaluationResults: "EvaluationResults";
  readonly PrimaryInput: "PrimaryInput";
};
export type DQTransformOutput =
  (typeof DQTransformOutput)[keyof typeof DQTransformOutput];
export interface DQResultsPublishingOptions {
  EvaluationContext?: string;
  ResultsS3Prefix?: string;
  CloudWatchMetricsEnabled?: boolean;
  ResultsPublishingEnabled?: boolean;
}
export declare const DQStopJobOnFailureTiming: {
  readonly AfterDataLoad: "AfterDataLoad";
  readonly Immediate: "Immediate";
};
export type DQStopJobOnFailureTiming =
  (typeof DQStopJobOnFailureTiming)[keyof typeof DQStopJobOnFailureTiming];
export interface DQStopJobOnFailureOptions {
  StopJobOnFailureTiming?: DQStopJobOnFailureTiming;
}
export interface EvaluateDataQuality {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Ruleset: string | undefined;
  Output?: DQTransformOutput;
  PublishingOptions?: DQResultsPublishingOptions;
  StopJobOnFailureOptions?: DQStopJobOnFailureOptions;
}
export interface EvaluateDataQualityMultiFrame {
  Name: string | undefined;
  Inputs: string[] | undefined;
  AdditionalDataSources?: Record<string, string>;
  Ruleset: string | undefined;
  PublishingOptions?: DQResultsPublishingOptions;
  AdditionalOptions?: Partial<Record<AdditionalOptionKeys, string>>;
  StopJobOnFailureOptions?: DQStopJobOnFailureOptions;
}
export interface FillMissingValues {
  Name: string | undefined;
  Inputs: string[] | undefined;
  ImputedPath: string | undefined;
  FilledPath?: string;
}
export declare const FilterOperation: {
  readonly EQ: "EQ";
  readonly GT: "GT";
  readonly GTE: "GTE";
  readonly ISNULL: "ISNULL";
  readonly LT: "LT";
  readonly LTE: "LTE";
  readonly REGEX: "REGEX";
};
export type FilterOperation =
  (typeof FilterOperation)[keyof typeof FilterOperation];
export declare const FilterValueType: {
  readonly COLUMNEXTRACTED: "COLUMNEXTRACTED";
  readonly CONSTANT: "CONSTANT";
};
export type FilterValueType =
  (typeof FilterValueType)[keyof typeof FilterValueType];
export interface FilterValue {
  Type: FilterValueType | undefined;
  Value: string[] | undefined;
}
export interface FilterExpression {
  Operation: FilterOperation | undefined;
  Negated?: boolean;
  Values: FilterValue[] | undefined;
}
export declare const FilterLogicalOperator: {
  readonly AND: "AND";
  readonly OR: "OR";
};
export type FilterLogicalOperator =
  (typeof FilterLogicalOperator)[keyof typeof FilterLogicalOperator];
export interface Filter {
  Name: string | undefined;
  Inputs: string[] | undefined;
  LogicalOperator: FilterLogicalOperator | undefined;
  Filters: FilterExpression[] | undefined;
}
export interface S3SourceAdditionalOptions {
  BoundedSize?: number;
  BoundedFiles?: number;
}
export interface GovernedCatalogSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
  PartitionPredicate?: string;
  AdditionalOptions?: S3SourceAdditionalOptions;
}
export declare const UpdateCatalogBehavior: {
  readonly LOG: "LOG";
  readonly UPDATE_IN_DATABASE: "UPDATE_IN_DATABASE";
};
export type UpdateCatalogBehavior =
  (typeof UpdateCatalogBehavior)[keyof typeof UpdateCatalogBehavior];
export interface CatalogSchemaChangePolicy {
  EnableUpdateCatalog?: boolean;
  UpdateBehavior?: UpdateCatalogBehavior;
}
export interface GovernedCatalogTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  PartitionKeys?: string[][];
  Table: string | undefined;
  Database: string | undefined;
  SchemaChangePolicy?: CatalogSchemaChangePolicy;
}
export declare const JDBCDataType: {
  readonly ARRAY: "ARRAY";
  readonly BIGINT: "BIGINT";
  readonly BINARY: "BINARY";
  readonly BIT: "BIT";
  readonly BLOB: "BLOB";
  readonly BOOLEAN: "BOOLEAN";
  readonly CHAR: "CHAR";
  readonly CLOB: "CLOB";
  readonly DATALINK: "DATALINK";
  readonly DATE: "DATE";
  readonly DECIMAL: "DECIMAL";
  readonly DISTINCT: "DISTINCT";
  readonly DOUBLE: "DOUBLE";
  readonly FLOAT: "FLOAT";
  readonly INTEGER: "INTEGER";
  readonly JAVA_OBJECT: "JAVA_OBJECT";
  readonly LONGNVARCHAR: "LONGNVARCHAR";
  readonly LONGVARBINARY: "LONGVARBINARY";
  readonly LONGVARCHAR: "LONGVARCHAR";
  readonly NCHAR: "NCHAR";
  readonly NCLOB: "NCLOB";
  readonly NULL: "NULL";
  readonly NUMERIC: "NUMERIC";
  readonly NVARCHAR: "NVARCHAR";
  readonly OTHER: "OTHER";
  readonly REAL: "REAL";
  readonly REF: "REF";
  readonly REF_CURSOR: "REF_CURSOR";
  readonly ROWID: "ROWID";
  readonly SMALLINT: "SMALLINT";
  readonly SQLXML: "SQLXML";
  readonly STRUCT: "STRUCT";
  readonly TIME: "TIME";
  readonly TIMESTAMP: "TIMESTAMP";
  readonly TIMESTAMP_WITH_TIMEZONE: "TIMESTAMP_WITH_TIMEZONE";
  readonly TIME_WITH_TIMEZONE: "TIME_WITH_TIMEZONE";
  readonly TINYINT: "TINYINT";
  readonly VARBINARY: "VARBINARY";
  readonly VARCHAR: "VARCHAR";
};
export type JDBCDataType = (typeof JDBCDataType)[keyof typeof JDBCDataType];
export declare const GlueRecordType: {
  readonly BIGDECIMAL: "BIGDECIMAL";
  readonly BYTE: "BYTE";
  readonly DATE: "DATE";
  readonly DOUBLE: "DOUBLE";
  readonly FLOAT: "FLOAT";
  readonly INT: "INT";
  readonly LONG: "LONG";
  readonly SHORT: "SHORT";
  readonly STRING: "STRING";
  readonly TIMESTAMP: "TIMESTAMP";
};
export type GlueRecordType =
  (typeof GlueRecordType)[keyof typeof GlueRecordType];
export interface JDBCConnectorOptions {
  FilterPredicate?: string;
  PartitionColumn?: string;
  LowerBound?: number;
  UpperBound?: number;
  NumPartitions?: number;
  JobBookmarkKeys?: string[];
  JobBookmarkKeysSortOrder?: string;
  DataTypeMapping?: Partial<Record<JDBCDataType, GlueRecordType>>;
}
export interface JDBCConnectorSource {
  Name: string | undefined;
  ConnectionName: string | undefined;
  ConnectorName: string | undefined;
  ConnectionType: string | undefined;
  AdditionalOptions?: JDBCConnectorOptions;
  ConnectionTable?: string;
  Query?: string;
  OutputSchemas?: GlueSchema[];
}
export interface JDBCConnectorTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  ConnectionName: string | undefined;
  ConnectionTable: string | undefined;
  ConnectorName: string | undefined;
  ConnectionType: string | undefined;
  AdditionalOptions?: Record<string, string>;
  OutputSchemas?: GlueSchema[];
}
export interface JoinColumn {
  From: string | undefined;
  Keys: string[][] | undefined;
}
export declare const JoinType: {
  readonly EQUIJOIN: "equijoin";
  readonly LEFT: "left";
  readonly LEFT_ANTI: "leftanti";
  readonly LEFT_SEMI: "leftsemi";
  readonly OUTER: "outer";
  readonly RIGHT: "right";
};
export type JoinType = (typeof JoinType)[keyof typeof JoinType];
export interface Join {
  Name: string | undefined;
  Inputs: string[] | undefined;
  JoinType: JoinType | undefined;
  Columns: JoinColumn[] | undefined;
}
export interface Merge {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Source: string | undefined;
  PrimaryKeys: string[][] | undefined;
}
export interface MicrosoftSQLServerCatalogSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface MicrosoftSQLServerCatalogTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface MySQLCatalogSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface MySQLCatalogTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface OracleSQLCatalogSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface OracleSQLCatalogTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export declare const PiiType: {
  readonly ColumnAudit: "ColumnAudit";
  readonly ColumnMasking: "ColumnMasking";
  readonly RowAudit: "RowAudit";
  readonly RowMasking: "RowMasking";
};
export type PiiType = (typeof PiiType)[keyof typeof PiiType];
export interface PIIDetection {
  Name: string | undefined;
  Inputs: string[] | undefined;
  PiiType: PiiType | undefined;
  EntityTypesToDetect: string[] | undefined;
  OutputColumnName?: string;
  SampleFraction?: number;
  ThresholdFraction?: number;
  MaskValue?: string;
}
export interface PostgreSQLCatalogSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface PostgreSQLCatalogTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface RecipeReference {
  RecipeArn: string | undefined;
  RecipeVersion: string | undefined;
}
export interface Recipe {
  Name: string | undefined;
  Inputs: string[] | undefined;
  RecipeReference: RecipeReference | undefined;
}
export interface RedshiftSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
  RedshiftTmpDir?: string;
  TmpDirIAMRole?: string;
}
export interface UpsertRedshiftTargetOptions {
  TableLocation?: string;
  ConnectionName?: string;
  UpsertKeys?: string[];
}
export interface RedshiftTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Database: string | undefined;
  Table: string | undefined;
  RedshiftTmpDir?: string;
  TmpDirIAMRole?: string;
  UpsertRedshiftOptions?: UpsertRedshiftTargetOptions;
}
export interface RelationalCatalogSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
}
export interface RenameField {
  Name: string | undefined;
  Inputs: string[] | undefined;
  SourcePath: string[] | undefined;
  TargetPath: string[] | undefined;
}
export interface S3CatalogDeltaSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
  AdditionalDeltaOptions?: Record<string, string>;
  OutputSchemas?: GlueSchema[];
}
export interface S3CatalogHudiSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
  AdditionalHudiOptions?: Record<string, string>;
  OutputSchemas?: GlueSchema[];
}
export interface S3CatalogSource {
  Name: string | undefined;
  Database: string | undefined;
  Table: string | undefined;
  PartitionPredicate?: string;
  AdditionalOptions?: S3SourceAdditionalOptions;
}
export interface S3CatalogTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  PartitionKeys?: string[][];
  Table: string | undefined;
  Database: string | undefined;
  SchemaChangePolicy?: CatalogSchemaChangePolicy;
}
export interface S3DirectSourceAdditionalOptions {
  BoundedSize?: number;
  BoundedFiles?: number;
  EnableSamplePath?: boolean;
  SamplePath?: string;
}
export declare const CompressionType: {
  readonly BZIP2: "bzip2";
  readonly GZIP: "gzip";
};
export type CompressionType =
  (typeof CompressionType)[keyof typeof CompressionType];
export declare const QuoteChar: {
  readonly DISABLED: "disabled";
  readonly QUILLEMET: "quillemet";
  readonly QUOTE: "quote";
  readonly SINGLE_QUOTE: "single_quote";
};
export type QuoteChar = (typeof QuoteChar)[keyof typeof QuoteChar];
export declare const Separator: {
  readonly COMMA: "comma";
  readonly CTRLA: "ctrla";
  readonly PIPE: "pipe";
  readonly SEMICOLON: "semicolon";
  readonly TAB: "tab";
};
export type Separator = (typeof Separator)[keyof typeof Separator];
export interface S3CsvSource {
  Name: string | undefined;
  Paths: string[] | undefined;
  CompressionType?: CompressionType;
  Exclusions?: string[];
  GroupSize?: string;
  GroupFiles?: string;
  Recurse?: boolean;
  MaxBand?: number;
  MaxFilesInBand?: number;
  AdditionalOptions?: S3DirectSourceAdditionalOptions;
  Separator: Separator | undefined;
  Escaper?: string;
  QuoteChar: QuoteChar | undefined;
  Multiline?: boolean;
  WithHeader?: boolean;
  WriteHeader?: boolean;
  SkipFirst?: boolean;
  OptimizePerformance?: boolean;
  OutputSchemas?: GlueSchema[];
}
export interface S3DeltaCatalogTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  PartitionKeys?: string[][];
  Table: string | undefined;
  Database: string | undefined;
  AdditionalOptions?: Record<string, string>;
  SchemaChangePolicy?: CatalogSchemaChangePolicy;
}
export declare const DeltaTargetCompressionType: {
  readonly SNAPPY: "snappy";
  readonly UNCOMPRESSED: "uncompressed";
};
export type DeltaTargetCompressionType =
  (typeof DeltaTargetCompressionType)[keyof typeof DeltaTargetCompressionType];
export declare const TargetFormat: {
  readonly AVRO: "avro";
  readonly CSV: "csv";
  readonly DELTA: "delta";
  readonly HUDI: "hudi";
  readonly JSON: "json";
  readonly ORC: "orc";
  readonly PARQUET: "parquet";
};
export type TargetFormat = (typeof TargetFormat)[keyof typeof TargetFormat];
export interface DirectSchemaChangePolicy {
  EnableUpdateCatalog?: boolean;
  UpdateBehavior?: UpdateCatalogBehavior;
  Table?: string;
  Database?: string;
}
export interface S3DeltaDirectTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  PartitionKeys?: string[][];
  Path: string | undefined;
  Compression: DeltaTargetCompressionType | undefined;
  Format: TargetFormat | undefined;
  AdditionalOptions?: Record<string, string>;
  SchemaChangePolicy?: DirectSchemaChangePolicy;
}
export interface S3DeltaSource {
  Name: string | undefined;
  Paths: string[] | undefined;
  AdditionalDeltaOptions?: Record<string, string>;
  AdditionalOptions?: S3DirectSourceAdditionalOptions;
  OutputSchemas?: GlueSchema[];
}
export interface S3DirectTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  PartitionKeys?: string[][];
  Path: string | undefined;
  Compression?: string;
  Format: TargetFormat | undefined;
  SchemaChangePolicy?: DirectSchemaChangePolicy;
}
export declare const ParquetCompressionType: {
  readonly GZIP: "gzip";
  readonly LZO: "lzo";
  readonly NONE: "none";
  readonly SNAPPY: "snappy";
  readonly UNCOMPRESSED: "uncompressed";
};
export type ParquetCompressionType =
  (typeof ParquetCompressionType)[keyof typeof ParquetCompressionType];
export interface S3GlueParquetTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  PartitionKeys?: string[][];
  Path: string | undefined;
  Compression?: ParquetCompressionType;
  SchemaChangePolicy?: DirectSchemaChangePolicy;
}
export interface S3HudiCatalogTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  PartitionKeys?: string[][];
  Table: string | undefined;
  Database: string | undefined;
  AdditionalOptions: Record<string, string> | undefined;
  SchemaChangePolicy?: CatalogSchemaChangePolicy;
}
export declare const HudiTargetCompressionType: {
  readonly GZIP: "gzip";
  readonly LZO: "lzo";
  readonly SNAPPY: "snappy";
  readonly UNCOMPRESSED: "uncompressed";
};
export type HudiTargetCompressionType =
  (typeof HudiTargetCompressionType)[keyof typeof HudiTargetCompressionType];
export interface S3HudiDirectTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Path: string | undefined;
  Compression: HudiTargetCompressionType | undefined;
  PartitionKeys?: string[][];
  Format: TargetFormat | undefined;
  AdditionalOptions: Record<string, string> | undefined;
  SchemaChangePolicy?: DirectSchemaChangePolicy;
}
export interface S3HudiSource {
  Name: string | undefined;
  Paths: string[] | undefined;
  AdditionalHudiOptions?: Record<string, string>;
  AdditionalOptions?: S3DirectSourceAdditionalOptions;
  OutputSchemas?: GlueSchema[];
}
export interface S3JsonSource {
  Name: string | undefined;
  Paths: string[] | undefined;
  CompressionType?: CompressionType;
  Exclusions?: string[];
  GroupSize?: string;
  GroupFiles?: string;
  Recurse?: boolean;
  MaxBand?: number;
  MaxFilesInBand?: number;
  AdditionalOptions?: S3DirectSourceAdditionalOptions;
  JsonPath?: string;
  Multiline?: boolean;
  OutputSchemas?: GlueSchema[];
}
export interface S3ParquetSource {
  Name: string | undefined;
  Paths: string[] | undefined;
  CompressionType?: ParquetCompressionType;
  Exclusions?: string[];
  GroupSize?: string;
  GroupFiles?: string;
  Recurse?: boolean;
  MaxBand?: number;
  MaxFilesInBand?: number;
  AdditionalOptions?: S3DirectSourceAdditionalOptions;
  OutputSchemas?: GlueSchema[];
}
export interface SelectFields {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Paths: string[][] | undefined;
}
export interface SelectFromCollection {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Index: number | undefined;
}
export interface SnowflakeNodeData {
  SourceType?: string;
  Connection?: Option;
  Schema?: string;
  Table?: string;
  Database?: string;
  TempDir?: string;
  IamRole?: Option;
  AdditionalOptions?: Record<string, string>;
  SampleQuery?: string;
  PreAction?: string;
  PostAction?: string;
  Action?: string;
  Upsert?: boolean;
  MergeAction?: string;
  MergeWhenMatched?: string;
  MergeWhenNotMatched?: string;
  MergeClause?: string;
  StagingTable?: string;
  SelectedColumns?: Option[];
  AutoPushdown?: boolean;
  TableSchema?: Option[];
}
export interface SnowflakeSource {
  Name: string | undefined;
  Data: SnowflakeNodeData | undefined;
  OutputSchemas?: GlueSchema[];
}
export interface SnowflakeTarget {
  Name: string | undefined;
  Data: SnowflakeNodeData | undefined;
  Inputs?: string[];
}
export interface SparkConnectorSource {
  Name: string | undefined;
  ConnectionName: string | undefined;
  ConnectorName: string | undefined;
  ConnectionType: string | undefined;
  AdditionalOptions?: Record<string, string>;
  OutputSchemas?: GlueSchema[];
}
export interface SparkConnectorTarget {
  Name: string | undefined;
  Inputs: string[] | undefined;
  ConnectionName: string | undefined;
  ConnectorName: string | undefined;
  ConnectionType: string | undefined;
  AdditionalOptions?: Record<string, string>;
  OutputSchemas?: GlueSchema[];
}
export interface SqlAlias {
  From: string | undefined;
  Alias: string | undefined;
}
export interface SparkSQL {
  Name: string | undefined;
  Inputs: string[] | undefined;
  SqlQuery: string | undefined;
  SqlAliases: SqlAlias[] | undefined;
  OutputSchemas?: GlueSchema[];
}
export interface Spigot {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Path: string | undefined;
  Topk?: number;
  Prob?: number;
}
export interface SplitFields {
  Name: string | undefined;
  Inputs: string[] | undefined;
  Paths: string[][] | undefined;
}
export declare const UnionType: {
  readonly ALL: "ALL";
  readonly DISTINCT: "DISTINCT";
};
export type UnionType = (typeof UnionType)[keyof typeof UnionType];
export interface Union {
  Name: string | undefined;
  Inputs: string[] | undefined;
  UnionType: UnionType | undefined;
}
export interface JobCommand {
  Name?: string;
  ScriptLocation?: string;
  PythonVersion?: string;
  Runtime?: string;
}
export interface ConnectionsList {
  Connections?: string[];
}
export declare const ExecutionClass: {
  readonly FLEX: "FLEX";
  readonly STANDARD: "STANDARD";
};
export type ExecutionClass =
  (typeof ExecutionClass)[keyof typeof ExecutionClass];
export interface ExecutionProperty {
  MaxConcurrentRuns?: number;
}
export declare const SourceControlAuthStrategy: {
  readonly AWS_SECRETS_MANAGER: "AWS_SECRETS_MANAGER";
  readonly PERSONAL_ACCESS_TOKEN: "PERSONAL_ACCESS_TOKEN";
};
export type SourceControlAuthStrategy =
  (typeof SourceControlAuthStrategy)[keyof typeof SourceControlAuthStrategy];
export declare const SourceControlProvider: {
  readonly AWS_CODE_COMMIT: "AWS_CODE_COMMIT";
  readonly BITBUCKET: "BITBUCKET";
  readonly GITHUB: "GITHUB";
  readonly GITLAB: "GITLAB";
};
export type SourceControlProvider =
  (typeof SourceControlProvider)[keyof typeof SourceControlProvider];
export interface SourceControlDetails {
  Provider?: SourceControlProvider;
  Repository?: string;
  Owner?: string;
  Branch?: string;
  Folder?: string;
  LastCommitId?: string;
  AuthStrategy?: SourceControlAuthStrategy;
  AuthToken?: string;
}
export interface BatchGetPartitionRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  PartitionsToGet: PartitionValueList[] | undefined;
}
export interface Partition {
  Values?: string[];
  DatabaseName?: string;
  TableName?: string;
  CreationTime?: Date;
  LastAccessTime?: Date;
  StorageDescriptor?: StorageDescriptor;
  Parameters?: Record<string, string>;
  LastAnalyzedTime?: Date;
  CatalogId?: string;
}
export interface BatchGetPartitionResponse {
  Partitions?: Partition[];
  UnprocessedKeys?: PartitionValueList[];
}
export declare const FederationSourceErrorCode: {
  readonly InternalServiceException: "InternalServiceException";
  readonly InvalidResponseException: "InvalidResponseException";
  readonly OperationNotSupportedException: "OperationNotSupportedException";
  readonly OperationTimeoutException: "OperationTimeoutException";
  readonly ThrottlingException: "ThrottlingException";
};
export type FederationSourceErrorCode =
  (typeof FederationSourceErrorCode)[keyof typeof FederationSourceErrorCode];
export declare class FederationSourceException extends __BaseException {
  readonly name: "FederationSourceException";
  readonly $fault: "client";
  FederationSourceErrorCode?: FederationSourceErrorCode;
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<FederationSourceException, __BaseException>
  );
}
export declare class FederationSourceRetryableException extends __BaseException {
  readonly name: "FederationSourceRetryableException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      FederationSourceRetryableException,
      __BaseException
    >
  );
}
export declare class InvalidStateException extends __BaseException {
  readonly name: "InvalidStateException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidStateException, __BaseException>
  );
}
export declare const TableOptimizerType: {
  readonly COMPACTION: "compaction";
};
export type TableOptimizerType =
  (typeof TableOptimizerType)[keyof typeof TableOptimizerType];
export interface BatchGetTableOptimizerEntry {
  catalogId?: string;
  databaseName?: string;
  tableName?: string;
  type?: TableOptimizerType;
}
export interface BatchGetTableOptimizerRequest {
  Entries: BatchGetTableOptimizerEntry[] | undefined;
}
export interface BatchGetTableOptimizerError {
  error?: ErrorDetail;
  catalogId?: string;
  databaseName?: string;
  tableName?: string;
  type?: TableOptimizerType;
}
export interface TableOptimizerConfiguration {
  roleArn?: string;
  enabled?: boolean;
}
export declare const TableOptimizerEventType: {
  readonly COMPLETED: "completed";
  readonly FAILED: "failed";
  readonly IN_PROGRESS: "in_progress";
  readonly STARTING: "starting";
};
export type TableOptimizerEventType =
  (typeof TableOptimizerEventType)[keyof typeof TableOptimizerEventType];
export interface RunMetrics {
  NumberOfBytesCompacted?: string;
  NumberOfFilesCompacted?: string;
  NumberOfDpus?: string;
  JobDurationInHour?: string;
}
export interface TableOptimizerRun {
  eventType?: TableOptimizerEventType;
  startTimestamp?: Date;
  endTimestamp?: Date;
  metrics?: RunMetrics;
  error?: string;
}
export interface TableOptimizer {
  type?: TableOptimizerType;
  configuration?: TableOptimizerConfiguration;
  lastRun?: TableOptimizerRun;
}
export interface BatchTableOptimizer {
  catalogId?: string;
  databaseName?: string;
  tableName?: string;
  tableOptimizer?: TableOptimizer;
}
export interface BatchGetTableOptimizerResponse {
  TableOptimizers?: BatchTableOptimizer[];
  Failures?: BatchGetTableOptimizerError[];
}
export interface BatchGetTriggersRequest {
  TriggerNames: string[] | undefined;
}
export interface EventBatchingCondition {
  BatchSize: number | undefined;
  BatchWindow?: number;
}
export declare const CrawlState: {
  readonly CANCELLED: "CANCELLED";
  readonly CANCELLING: "CANCELLING";
  readonly ERROR: "ERROR";
  readonly FAILED: "FAILED";
  readonly RUNNING: "RUNNING";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type CrawlState = (typeof CrawlState)[keyof typeof CrawlState];
export declare const LogicalOperator: {
  readonly EQUALS: "EQUALS";
};
export type LogicalOperator =
  (typeof LogicalOperator)[keyof typeof LogicalOperator];
export declare const JobRunState: {
  readonly ERROR: "ERROR";
  readonly FAILED: "FAILED";
  readonly RUNNING: "RUNNING";
  readonly STARTING: "STARTING";
  readonly STOPPED: "STOPPED";
  readonly STOPPING: "STOPPING";
  readonly SUCCEEDED: "SUCCEEDED";
  readonly TIMEOUT: "TIMEOUT";
  readonly WAITING: "WAITING";
};
export type JobRunState = (typeof JobRunState)[keyof typeof JobRunState];
export interface Condition {
  LogicalOperator?: LogicalOperator;
  JobName?: string;
  State?: JobRunState;
  CrawlerName?: string;
  CrawlState?: CrawlState;
}
export declare const Logical: {
  readonly AND: "AND";
  readonly ANY: "ANY";
};
export type Logical = (typeof Logical)[keyof typeof Logical];
export interface Predicate {
  Logical?: Logical;
  Conditions?: Condition[];
}
export declare const TriggerState: {
  readonly ACTIVATED: "ACTIVATED";
  readonly ACTIVATING: "ACTIVATING";
  readonly CREATED: "CREATED";
  readonly CREATING: "CREATING";
  readonly DEACTIVATED: "DEACTIVATED";
  readonly DEACTIVATING: "DEACTIVATING";
  readonly DELETING: "DELETING";
  readonly UPDATING: "UPDATING";
};
export type TriggerState = (typeof TriggerState)[keyof typeof TriggerState];
export declare const TriggerType: {
  readonly CONDITIONAL: "CONDITIONAL";
  readonly EVENT: "EVENT";
  readonly ON_DEMAND: "ON_DEMAND";
  readonly SCHEDULED: "SCHEDULED";
};
export type TriggerType = (typeof TriggerType)[keyof typeof TriggerType];
export interface Trigger {
  Name?: string;
  WorkflowName?: string;
  Id?: string;
  Type?: TriggerType;
  State?: TriggerState;
  Description?: string;
  Schedule?: string;
  Actions?: Action[];
  Predicate?: Predicate;
  EventBatchingCondition?: EventBatchingCondition;
}
export interface BatchGetTriggersResponse {
  Triggers?: Trigger[];
  TriggersNotFound?: string[];
}
export interface BatchGetWorkflowsRequest {
  Names: string[] | undefined;
  IncludeGraph?: boolean;
}
export interface BlueprintDetails {
  BlueprintName?: string;
  RunId?: string;
}
export interface Edge {
  SourceId?: string;
  DestinationId?: string;
}
export interface Crawl {
  State?: CrawlState;
  StartedOn?: Date;
  CompletedOn?: Date;
  ErrorMessage?: string;
  LogGroup?: string;
  LogStream?: string;
}
export interface CrawlerNodeDetails {
  Crawls?: Crawl[];
}
export interface Predecessor {
  JobName?: string;
  RunId?: string;
}
export interface JobRun {
  Id?: string;
  Attempt?: number;
  PreviousRunId?: string;
  TriggerName?: string;
  JobName?: string;
  StartedOn?: Date;
  LastModifiedOn?: Date;
  CompletedOn?: Date;
  JobRunState?: JobRunState;
  Arguments?: Record<string, string>;
  ErrorMessage?: string;
  PredecessorRuns?: Predecessor[];
  AllocatedCapacity?: number;
  ExecutionTime?: number;
  Timeout?: number;
  MaxCapacity?: number;
  WorkerType?: WorkerType;
  NumberOfWorkers?: number;
  SecurityConfiguration?: string;
  LogGroupName?: string;
  NotificationProperty?: NotificationProperty;
  GlueVersion?: string;
  DPUSeconds?: number;
  ExecutionClass?: ExecutionClass;
}
export interface JobNodeDetails {
  JobRuns?: JobRun[];
}
export interface TriggerNodeDetails {
  Trigger?: Trigger;
}
export declare const NodeType: {
  readonly CRAWLER: "CRAWLER";
  readonly JOB: "JOB";
  readonly TRIGGER: "TRIGGER";
};
export type NodeType = (typeof NodeType)[keyof typeof NodeType];
export interface Node {
  Type?: NodeType;
  Name?: string;
  UniqueId?: string;
  TriggerDetails?: TriggerNodeDetails;
  JobDetails?: JobNodeDetails;
  CrawlerDetails?: CrawlerNodeDetails;
}
export interface WorkflowGraph {
  Nodes?: Node[];
  Edges?: Edge[];
}
export interface StartingEventBatchCondition {
  BatchSize?: number;
  BatchWindow?: number;
}
export interface WorkflowRunStatistics {
  TotalActions?: number;
  TimeoutActions?: number;
  FailedActions?: number;
  StoppedActions?: number;
  SucceededActions?: number;
  RunningActions?: number;
  ErroredActions?: number;
  WaitingActions?: number;
}
export declare const WorkflowRunStatus: {
  readonly COMPLETED: "COMPLETED";
  readonly ERROR: "ERROR";
  readonly RUNNING: "RUNNING";
  readonly STOPPED: "STOPPED";
  readonly STOPPING: "STOPPING";
};
export type WorkflowRunStatus =
  (typeof WorkflowRunStatus)[keyof typeof WorkflowRunStatus];
export interface WorkflowRun {
  Name?: string;
  WorkflowRunId?: string;
  PreviousRunId?: string;
  WorkflowRunProperties?: Record<string, string>;
  StartedOn?: Date;
  CompletedOn?: Date;
  Status?: WorkflowRunStatus;
  ErrorMessage?: string;
  Statistics?: WorkflowRunStatistics;
  Graph?: WorkflowGraph;
  StartingEventBatchCondition?: StartingEventBatchCondition;
}
export interface Workflow {
  Name?: string;
  Description?: string;
  DefaultRunProperties?: Record<string, string>;
  CreatedOn?: Date;
  LastModifiedOn?: Date;
  LastRun?: WorkflowRun;
  Graph?: WorkflowGraph;
  MaxConcurrentRuns?: number;
  BlueprintDetails?: BlueprintDetails;
}
export interface BatchGetWorkflowsResponse {
  Workflows?: Workflow[];
  MissingWorkflows?: string[];
}
export interface BatchStopJobRunRequest {
  JobName: string | undefined;
  JobRunIds: string[] | undefined;
}
export interface BatchStopJobRunError {
  JobName?: string;
  JobRunId?: string;
  ErrorDetail?: ErrorDetail;
}
export interface BatchStopJobRunSuccessfulSubmission {
  JobName?: string;
  JobRunId?: string;
}
export interface BatchStopJobRunResponse {
  SuccessfulSubmissions?: BatchStopJobRunSuccessfulSubmission[];
  Errors?: BatchStopJobRunError[];
}
export interface BatchUpdatePartitionRequestEntry {
  PartitionValueList: string[] | undefined;
  PartitionInput: PartitionInput | undefined;
}
export interface BatchUpdatePartitionRequest {
  CatalogId?: string;
  DatabaseName: string | undefined;
  TableName: string | undefined;
  Entries: BatchUpdatePartitionRequestEntry[] | undefined;
}
export interface BatchUpdatePartitionFailureEntry {
  PartitionValueList?: string[];
  ErrorDetail?: ErrorDetail;
}
export interface BatchUpdatePartitionResponse {
  Errors?: BatchUpdatePartitionFailureEntry[];
}
export interface CancelDataQualityRuleRecommendationRunRequest {
  RunId: string | undefined;
}
export interface CancelDataQualityRuleRecommendationRunResponse {}
export interface CancelDataQualityRulesetEvaluationRunRequest {
  RunId: string | undefined;
}
export interface CancelDataQualityRulesetEvaluationRunResponse {}
export interface CancelMLTaskRunRequest {
  TransformId: string | undefined;
  TaskRunId: string | undefined;
}
export declare const TaskStatusType: {
  readonly FAILED: "FAILED";
  readonly RUNNING: "RUNNING";
  readonly STARTING: "STARTING";
  readonly STOPPED: "STOPPED";
  readonly STOPPING: "STOPPING";
  readonly SUCCEEDED: "SUCCEEDED";
  readonly TIMEOUT: "TIMEOUT";
};
export type TaskStatusType =
  (typeof TaskStatusType)[keyof typeof TaskStatusType];
export interface CancelMLTaskRunResponse {
  TransformId?: string;
  TaskRunId?: string;
  Status?: TaskStatusType;
}
export interface CancelStatementRequest {
  SessionId: string | undefined;
  Id: number | undefined;
  RequestOrigin?: string;
}
export interface CancelStatementResponse {}
export declare class IllegalSessionStateException extends __BaseException {
  readonly name: "IllegalSessionStateException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<IllegalSessionStateException, __BaseException>
  );
}
export declare const DataFormat: {
  readonly AVRO: "AVRO";
  readonly JSON: "JSON";
  readonly PROTOBUF: "PROTOBUF";
};
export type DataFormat = (typeof DataFormat)[keyof typeof DataFormat];
export interface CheckSchemaVersionValidityInput {
  DataFormat: DataFormat | undefined;
  SchemaDefinition: string | undefined;
}
export interface CheckSchemaVersionValidityResponse {
  Valid?: boolean;
  Error?: string;
}
export interface CreateBlueprintRequest {
  Name: string | undefined;
  Description?: string;
  BlueprintLocation: string | undefined;
  Tags?: Record<string, string>;
}
export interface CreateBlueprintResponse {
  Name?: string;
}
export declare const CsvHeaderOption: {
  readonly ABSENT: "ABSENT";
  readonly PRESENT: "PRESENT";
  readonly UNKNOWN: "UNKNOWN";
};
export type CsvHeaderOption =
  (typeof CsvHeaderOption)[keyof typeof CsvHeaderOption];
export declare const CsvSerdeOption: {
  readonly LazySimpleSerDe: "LazySimpleSerDe";
  readonly None: "None";
  readonly OpenCSVSerDe: "OpenCSVSerDe";
};
export type CsvSerdeOption =
  (typeof CsvSerdeOption)[keyof typeof CsvSerdeOption];
export interface CreateCsvClassifierRequest {
  Name: string | undefined;
  Delimiter?: string;
  QuoteSymbol?: string;
  ContainsHeader?: CsvHeaderOption;
  Header?: string[];
  DisableValueTrimming?: boolean;
  AllowSingleColumn?: boolean;
  CustomDatatypeConfigured?: boolean;
  CustomDatatypes?: string[];
  Serde?: CsvSerdeOption;
}
export interface CreateGrokClassifierRequest {
  Classification: string | undefined;
  Name: string | undefined;
  GrokPattern: string | undefined;
  CustomPatterns?: string;
}
export interface CreateJsonClassifierRequest {
  Name: string | undefined;
  JsonPath: string | undefined;
}
export interface CreateXMLClassifierRequest {
  Classification: string | undefined;
  Name: string | undefined;
  RowTag?: string;
}
export interface CreateClassifierRequest {
  GrokClassifier?: CreateGrokClassifierRequest;
  XMLClassifier?: CreateXMLClassifierRequest;
  JsonClassifier?: CreateJsonClassifierRequest;
  CsvClassifier?: CreateCsvClassifierRequest;
}
export interface CreateClassifierResponse {}
export declare const ConnectionPropertyKey: {
  readonly CONFIG_FILES: "CONFIG_FILES";
  readonly CONNECTION_URL: "CONNECTION_URL";
  readonly CONNECTOR_CLASS_NAME: "CONNECTOR_CLASS_NAME";
  readonly CONNECTOR_TYPE: "CONNECTOR_TYPE";
  readonly CONNECTOR_URL: "CONNECTOR_URL";
  readonly CUSTOM_JDBC_CERT: "CUSTOM_JDBC_CERT";
  readonly CUSTOM_JDBC_CERT_STRING: "CUSTOM_JDBC_CERT_STRING";
  readonly ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD: "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD";
  readonly ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD: "ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD";
  readonly ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD: "ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD";
  readonly ENCRYPTED_PASSWORD: "ENCRYPTED_PASSWORD";
  readonly HOST: "HOST";
  readonly INSTANCE_ID: "INSTANCE_ID";
  readonly JDBC_CONNECTION_URL: "JDBC_CONNECTION_URL";
  readonly JDBC_DRIVER_CLASS_NAME: "JDBC_DRIVER_CLASS_NAME";
  readonly JDBC_DRIVER_JAR_URI: "JDBC_DRIVER_JAR_URI";
  readonly JDBC_ENFORCE_SSL: "JDBC_ENFORCE_SSL";
  readonly JDBC_ENGINE: "JDBC_ENGINE";
  readonly JDBC_ENGINE_VERSION: "JDBC_ENGINE_VERSION";
  readonly KAFKA_BOOTSTRAP_SERVERS: "KAFKA_BOOTSTRAP_SERVERS";
  readonly KAFKA_CLIENT_KEYSTORE: "KAFKA_CLIENT_KEYSTORE";
  readonly KAFKA_CLIENT_KEYSTORE_PASSWORD: "KAFKA_CLIENT_KEYSTORE_PASSWORD";
  readonly KAFKA_CLIENT_KEY_PASSWORD: "KAFKA_CLIENT_KEY_PASSWORD";
  readonly KAFKA_CUSTOM_CERT: "KAFKA_CUSTOM_CERT";
  readonly KAFKA_SASL_GSSAPI_KEYTAB: "KAFKA_SASL_GSSAPI_KEYTAB";
  readonly KAFKA_SASL_GSSAPI_KRB5_CONF: "KAFKA_SASL_GSSAPI_KRB5_CONF";
  readonly KAFKA_SASL_GSSAPI_PRINCIPAL: "KAFKA_SASL_GSSAPI_PRINCIPAL";
  readonly KAFKA_SASL_GSSAPI_SERVICE: "KAFKA_SASL_GSSAPI_SERVICE";
  readonly KAFKA_SASL_MECHANISM: "KAFKA_SASL_MECHANISM";
  readonly KAFKA_SASL_SCRAM_PASSWORD: "KAFKA_SASL_SCRAM_PASSWORD";
  readonly KAFKA_SASL_SCRAM_SECRETS_ARN: "KAFKA_SASL_SCRAM_SECRETS_ARN";
  readonly KAFKA_SASL_SCRAM_USERNAME: "KAFKA_SASL_SCRAM_USERNAME";
  readonly KAFKA_SKIP_CUSTOM_CERT_VALIDATION: "KAFKA_SKIP_CUSTOM_CERT_VALIDATION";
  readonly KAFKA_SSL_ENABLED: "KAFKA_SSL_ENABLED";
  readonly PASSWORD: "PASSWORD";
  readonly PORT: "PORT";
  readonly SECRET_ID: "SECRET_ID";
  readonly SKIP_CUSTOM_JDBC_CERT_VALIDATION: "SKIP_CUSTOM_JDBC_CERT_VALIDATION";
  readonly USER_NAME: "USERNAME";
};
export type ConnectionPropertyKey =
  (typeof ConnectionPropertyKey)[keyof typeof ConnectionPropertyKey];
export declare const ConnectionType: {
  readonly CUSTOM: "CUSTOM";
  readonly JDBC: "JDBC";
  readonly KAFKA: "KAFKA";
  readonly MARKETPLACE: "MARKETPLACE";
  readonly MONGODB: "MONGODB";
  readonly NETWORK: "NETWORK";
  readonly SFTP: "SFTP";
};
export type ConnectionType =
  (typeof ConnectionType)[keyof typeof ConnectionType];
export interface PhysicalConnectionRequirements {
  SubnetId?: string;
  SecurityGroupIdList?: string[];
  AvailabilityZone?: string;
}
export interface ConnectionInput {
  Name: string | undefined;
  Description?: string;
  ConnectionType: ConnectionType | undefined;
  MatchCriteria?: string[];
  ConnectionProperties:
    | Partial<Record<ConnectionPropertyKey, string>>
    | undefined;
  PhysicalConnectionRequirements?: PhysicalConnectionRequirements;
}
export interface CreateConnectionRequest {
  CatalogId?: string;
  ConnectionInput: ConnectionInput | undefined;
  Tags?: Record<string, string>;
}
export interface CreateConnectionResponse {}
export interface CreateCrawlerRequest {
  Name: string | undefined;
  Role: string | undefined;
  DatabaseName?: string;
  Description?: string;
  Targets: CrawlerTargets | undefined;
  Schedule?: string;
  Classifiers?: string[];
  TablePrefix?: string;
  SchemaChangePolicy?: SchemaChangePolicy;
  RecrawlPolicy?: RecrawlPolicy;
  LineageConfiguration?: LineageConfiguration;
  LakeFormationConfiguration?: LakeFormationConfiguration;
  Configuration?: string;
  CrawlerSecurityConfiguration?: string;
  Tags?: Record<string, string>;
}
export interface CreateCrawlerResponse {}
export interface CreateCustomEntityTypeRequest {
  Name: string | undefined;
  RegexString: string | undefined;
  ContextWords?: string[];
  Tags?: Record<string, string>;
}
